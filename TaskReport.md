# Решение задачи на составление решённого кроссворда слов
Данная задача интересна с алгоритмической точки зрения, 
поскольлко полноценное алгоритмическое решение, максимизирующее
связность схемы, является сложной и нетривиальной задачей
## Класс NewCrossBoard
* Данный класс симулирует задачу расставления слов по клеткам и содержит следующие методы и поля:
  * listOfUnplacedWords - список для отслеживания слов, которые необходимо расставить
  * listOfPlacedWords - список для отслеживания уже вставленных слов
  * matr - матрица класса ResizableMatrix, которая имеет все необходимые для алгоритма решения инструменты:
    * изменение размеров
    * подгонка размеров под текущее решение
    * работа с абсолютными координатами элементов матрицы
    * работа с относительными координатами элементов матрицы
  * wordCrossowersRelativeCoords - сохраняет все пересечения слов
  * wordDensityCoeff - коэффицент пересечений для оценки качества решения
  ### Из основных методов для решения задачи выделим:
  #### PlaceWord
* Данный метод пытается найти место, куда вставить слово и, при нахождении такого, вставляет в матрицу
* Данный метод имеет временную сложность O(n^3)
* Если это первое слово в матрице, то он просто расширяет матрицу, вставляет слово горизонтально без проверок
и внутри матрицу ResizableMatrix происходит относительных координат матрицы, которая будет работать относительно первой
вставленной буквы первого вставленного слова
  #### Методы IsFreeToPlaceHoriz и IsFreeToPlaceVert
* Данные методы проверяют, есть ли место для вставки слова в матрице, если нет, то расширяют матрицу, созданную с помощью
класса ResizableMatrix, далее, используют набор эвристик, для проверки условий вставки
* Если решение найти не удалось, они возвращают матрицу к исходным размерам
  #### Метод DeleteWord
* Этот метод удаляет слово из матрицы, заносит его обратно в список не вставленных слов и удаляет из вставленных
  #### Метод Solve
* Данный метод всего лишь вызывает следующий метод по решению задачи с помощью алгоритма бэктрекинга
  #### Метод BacktrackingAlg
* Этот метод реализуется рекурсивно, хотя, если набор слов будет чрезмерно большим и приведёт к 
StackOverflow Exception, не составляет никакого труда переписать рекурсивный алгоритм с помощью итераций и отдельно
созданного стека, который будет хранится в куче и иметь значительную вместимость, чтобы учитывать все возможные решения
нашего алгоритма бэктрекинга
* Данный метод работает по следующему принципу:
  * Выбор - это первый этап, который выбирает подходящий элемент, чтобы продолжить решение задачи
  * Проверка - это второй этап, который проверяет состояние решения на условия задачи
  * Откат - это третий этап, который представляет собой возврат к предыдущему состоянию решения (бэктрекинг)
  * Продолжение - это четвёртый этап, который продолжает алгоритм
## Класс ResizableMatrix
* Данный класс представляет собой модификацию классической матрицы T[,]
* У данного класса есть следующие модификкации:
  * Наличие полей, которые учитывают смещения вверх и влево, относительно первой вставленной буквы в матрицу исходного размера
  * Наличие методов, которые позволяют работать с абсолютными координатами матрицы и относительным по отношению к первой вставленной букве
  * Метод Fit(), который обрезает лишнее с матрицы, если её расширение оказалось всё равно неудачным для вставки слова
  * Некоторые проверки на граничные условия, чтобы отлавливать ошибки

## Оптимизации схемы:
* Для увеличения связности схемы мы используем алгоритм бэктрекинга с некоторым численным параметром, которые проверяет
удовлетворяет ли наше текущее решение тому уровню связности, которое мы задали
* Эмпирически проверено, что алгоритм многократно быстрее справляется с нахождением итогового решения заполнения кроссворда,
когда алгоритм бэктрекинга начинается со вставки в кроссворд слов наименьшей длинны

## Выводы:
* Алгоритм бэктрекинга довольно громоздкий в плане временной и пространственной сложности, но
он позволяет перебрать все потенциально возможные решения комбинаторной задачи, например, проблема заполнения кроссворда.
* Данный алгоритм можно ускорить, если задать дополнительные ограничения, которые будут проверяться в ходе решения задачи.